
<!DOCTYPE html>
<!-- Variable: page_title       | text | Valor por defecto: Rompecabezas del Amor -->
<!-- Variable: main_title       | text | Valor por defecto: Rompecabezas del Amor -->
<!-- Variable: puzzle_image     | url  | Valor por defecto: https://cdn.pensador.com/es/imagenes/sin-ti-mi-vida-tendri-a-menos-luz-te-amo-mi-amor.jpg -->
<!-- Variable: grid_size        | text | Valor por defecto: 2 -->
<!-- Variable: completion_title | text | Valor por defecto: Este es el texto del final cuando termina el puzzle -->
<!-- Variable: completion_button| text | Valor por defecto: Cerrar -->
<!-- Variable: music_file       | url  | Valor por defecto: Chino&Nacho - Niña Bonita.mp3 -->
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Rompecabezas del Amor</title>
  <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body class="flex flex-col items-center justify-start min-h-screen p-2">
  <canvas id="backgroundCanvas"></canvas>
  <h1 id="mainTitle" class="font-extrabold text-3xl sm:text-6xl md:text-[3.5rem] text-center">Rompecabezas del Amor</h1> //Este es la linea de arriva del titulo
  <div id="container" class="mb-4"></div>
  
  <div class="button-container flex flex-row justify-center items-center gap-6 w-full max-w-lg">
    <button id="previewButton" class="shadow-xl">Ver Imagen</button>
        <button id="playPauseButton" class="shadow-xl">▶</button>
        <button id="resetButton" class="shadow-xl">Reinciar</button>
    
  </div>
    <audio id="backgroundMusic" src="Chino&amp;Nacho%20-%20Niña%20Bonita.mp3" preload="auto" loop></audio>
    <div id="previewModal">
    <img id="previewImage" src="https://cdn.pensador.com/es/imagenes/sin-ti-mi-vida-tendri-a-menos-luz-te-amo-mi-amor.jpg " alt="Puzzle Preview">  //En esta linea es la prevew de la imagen
    <button id="closeModal">Cerrar</button>
  </div>
    <div id="completionModal">
      <div>
       <h2 id="completionTitle">Este es el texto del final cuando termina el puzzle</h2>    //Este es el texto del final cuando termina el puzzle

<button id="closeCompletionModal" style="margin-left: 20px;">Cerrar</button>


      </div>
    </div>
    <audio id="correctSound" src="bien.mp3" preload="auto"></audio>

  <script>
    // Romantic particle background with glowing hearts and sparkles
    const canvas = document.getElementById('backgroundCanvas');
    const ctx = canvas.getContext('2d');
    let particles = [];

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initParticles();
    }
    

    function initParticles() {
      particles = [];
      const particleCount = Math.floor(window.innerWidth * window.innerHeight / 10000);
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 20 + 10,
          speedX: (Math.random() - 0.5) * 0.5,
          speedY: (Math.random() - 0.5) * 0.5,
          opacity: Math.random() * 0.5 + 0.3,
          type: Math.random() < 0.7 ? 'heart' : 'sparkle',
          rotation: Math.random() * 360,
          rotationSpeed: (Math.random() - 0.5) * 2
        });
      }
    }

    function drawHeart(x, y, size, rotation) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate((rotation * Math.PI) / 180);
      ctx.beginPath();
      ctx.moveTo(0, size * 0.3);
      ctx.bezierCurveTo(
        -size * 0.5, -size * 0.5, -size, -size * 0.2, -size, size * 0.3
      );
      ctx.bezierCurveTo(-size, size * 0.8, 0, size * 1.2, 0, size * 1.2);
      ctx.bezierCurveTo(0, size * 1.2, size, size * 0.8, size, size * 0.3);
      ctx.bezierCurveTo(size, -size * 0.2, size * 0.5, -size * 0.5, 0, size * 0.3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawSparkle(x, y, size) {
      ctx.beginPath();
      ctx.moveTo(x, y - size);
      ctx.lineTo(x, y + size);
      ctx.moveTo(x - size, y);
      ctx.lineTo(x + size, y);
      ctx.moveTo(x - size * 0.7, y - size * 0.7);
      ctx.lineTo(x + size * 0.7, y + size * 0.7);
      ctx.moveTo(x - size * 0.7, y + size * 0.7);
      ctx.lineTo(x + size * 0.7, y - size * 0.7);
      ctx.stroke();
    }

    function drawParticles() {
      ctx.fillStyle = 'rgba(251, 207, 232, 0.2)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      particles.forEach(p => {
        if (p.type === 'heart') {
          ctx.fillStyle = `rgba(219, 39, 119, ${p.opacity})`;
          drawHeart(p.x, p.y, p.size / 2, p.rotation);
        } else {
          ctx.strokeStyle = `rgba(255, 255, 255, ${p.opacity})`;
          ctx.lineWidth = 2;
          drawSparkle(p.x, p.y, p.size / 2);
        }

        p.x += p.speedX;
        p.y += p.speedY;
        p.rotation += p.rotationSpeed;
        p.opacity = Math.max(0.3, p.opacity + (Math.random() - 0.5) * 0.02);

        if (p.x < 0 || p.x > canvas.width) p.speedX = -p.speedX;
        if (p.y < 0 || p.y > canvas.height) p.speedY = -p.speedY;
      });
    }

    function animateParticles() {
      drawParticles();
      requestAnimationFrame(animateParticles);
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    animateParticles();

    // Leer parámetros JSON desde URL ANTES de crear el puzzle
    function getJsonParam() {
      try {
        const url = new URL(window.location.href);
        const raw = url.searchParams.get('json');
        if (!raw) return null;
        const decoded = decodeURIComponent(raw);
        return JSON.parse(decoded);
      } catch (e) {
        return null;
      }
    }

    let GRID_SIZE = 2; //En esta linea se define el numero de piezaz viendo como por ejemplo 5 = 5 x 5 = 25 piezas
    const jsonParams = getJsonParam();
    if (jsonParams && jsonParams.grid_size) {
      const newSize = parseInt(jsonParams.grid_size, 10);
      if (newSize >= 2 && newSize <= 8) {
        GRID_SIZE = newSize;
      }
    }

    let PIECE_SIZE = 100;
    let stage, layer, slotLayer, pieces = [], imageObj = null;

    const connectors = { top: [], left: [] };

    let tabRadius, tabWidth, tabDepth, tabPosition;

    function calculateDimensions() {
      const availableWidth = window.innerWidth - 40;
      let ps = Math.floor(Math.min(availableWidth, 600) / GRID_SIZE);
      let boardSize = ps * GRID_SIZE;
      let extraWidth = 0;
      let extraHeight = 0;
      if (window.innerWidth > 640) {
        extraWidth = 400;
        extraHeight = 0;
      } else {
        extraWidth = 0;
        extraHeight = Math.max(250, ps * 2);
      }
      let totalWidth = boardSize + extraWidth;
      let totalHeight = boardSize + extraHeight;
      const maxTotalWidth = Math.min(availableWidth, 900);
      if (totalWidth > maxTotalWidth) {
        extraWidth = maxTotalWidth - boardSize;
        totalWidth = maxTotalWidth;
      }
      const maxTotalHeight = window.innerHeight - 140;
      if (totalHeight > maxTotalHeight) {
        extraHeight = maxTotalHeight - boardSize;
        totalHeight = maxTotalHeight;
      }
      return { ps, boardSize, extraWidth, extraHeight, totalWidth, totalHeight };
    }

    function initStage(boardSize, extraWidth, extraHeight) {
      stage = new Konva.Stage({
        container: 'container',
        width: boardSize + extraWidth,
        height: boardSize + extraHeight
      });

      slotLayer = new Konva.Layer();
      layer = new Konva.Layer();
      stage.add(slotLayer);
      stage.add(layer);

      const container = document.getElementById('container');
      container.style.width = `${boardSize + extraWidth}px`;
      container.style.height = `${boardSize + extraHeight}px`;
    }

    imageObj = new Image();
    imageObj.src = 'data:image/webp;base64,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';  //En esta linea se define la imagen del puzzle
    imageObj.onload = () => {
      const dims = calculateDimensions();
      PIECE_SIZE = dims.ps;

      tabRadius = PIECE_SIZE * 0.35;
      tabWidth = PIECE_SIZE * 0.4;
      tabDepth = PIECE_SIZE * 0.21;
      tabPosition = PIECE_SIZE * 0.5;

      initStage(dims.boardSize, dims.extraWidth, dims.extraHeight);
      createPuzzle();
    };

    document.getElementById('resetButton').addEventListener('click', () => {
      if (imageObj) {
        const dims = calculateDimensions();
        PIECE_SIZE = dims.ps;

        tabRadius = PIECE_SIZE * 0.35;
        tabWidth = PIECE_SIZE * 0.4;
        tabDepth = PIECE_SIZE * 0.21;
        tabPosition = PIECE_SIZE * 0.5;

        initStage(dims.boardSize, dims.extraWidth, dims.extraHeight);
        createPuzzle();
      }
    });

    document.getElementById('previewButton').addEventListener('click', () => {
      document.getElementById('previewModal').style.display = 'flex';
    });

    document.getElementById('closeModal').addEventListener('click', () => {
      document.getElementById('previewModal').style.display = 'none';
    });

    document.getElementById('closeCompletionModal').addEventListener('click', () => {
      document.getElementById('completionModal').style.display = 'none';
    });

    window.addEventListener('resize', () => {
      if (imageObj) {
        const dims = calculateDimensions();
        PIECE_SIZE = dims.ps;

        tabRadius = PIECE_SIZE * 0.35;
        tabWidth = PIECE_SIZE * 0.4;
        tabDepth = PIECE_SIZE * 0.21;
        tabPosition = PIECE_SIZE * 0.5;

        initStage(dims.boardSize, dims.extraWidth, dims.extraHeight);
        createPuzzle();
        initParticles();
      }
    });

    function createPuzzle() {
      pieces = [];
      layer.removeChildren();
      slotLayer.removeChildren();

      connectors.top = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
      connectors.left = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));

      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          if (row > 0) {
            connectors.top[row][col] = -connectors.top[row - 1][col];
          } else {
            connectors.top[row][col] = Math.random() > 0.5 ? 1 : -1;
          }
          if (col > 0) {
            connectors.left[row][col] = -connectors.left[row][col - 1];
          } else {
            connectors.left[row][col] = Math.random() > 0.5 ? 1 : -1;
          }
        }
      }

      const boardSize = PIECE_SIZE * GRID_SIZE;
      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          const slot = new Konva.Path({
            x: col * PIECE_SIZE,
            y: row * PIECE_SIZE,
            data: generatePuzzlePiecePath(row, col),
            stroke: '#f9a8d4',
            strokeWidth: 1,
            dash: [4, 4]
          });
          slotLayer.add(slot);

          const piece = createPuzzlePiece(row, col);
          pieces.push(piece);
          layer.add(piece);
        }
      }

      slotLayer.draw();
      shufflePieces(boardSize);
      layer.draw();
    }

    function createPuzzlePiece(row, col) {
      const group = new Konva.Group({
        x: 0, y: 0,
        draggable: true,
        correctX: col * PIECE_SIZE,
        correctY: row * PIECE_SIZE,
        row, col,
        dragBoundFunc: function(pos) {
  const containerEl = stage.container();
  const maxX = containerEl.offsetWidth  - PIECE_SIZE;
  const maxY = containerEl.offsetHeight - PIECE_SIZE;
  return {
    x: Math.max(0, Math.min(pos.x, maxX)),
    y: Math.max(0, Math.min(pos.y, maxY))
  };
}
      });

      const fullSize = PIECE_SIZE * GRID_SIZE;
      const scaleX = imageObj.width / fullSize;
      const scaleY = imageObj.height / fullSize;

      const shape = new Konva.Path({
        x: 0, y: 0,
        data: generatePuzzlePiecePath(row, col),
        fillPatternImage: imageObj,
        fillPatternOffset: {
          x: col * PIECE_SIZE * scaleX,
          y: row * PIECE_SIZE * scaleY
        },
        fillPatternScale: {
          x: 1 / scaleX,
          y: 1 / scaleY
        },
        stroke: '#db2777',
        strokeWidth: 1
      });

      group.add(shape);

      group.on('dragstart touchstart', () => {
        group.moveToTop();
        layer.draw();
      });

      group.on('dragend touchend', () => {
        const { correctX, correctY } = group.attrs;
        if (Math.abs(group.x() - correctX) < PIECE_SIZE / 4 &&
            Math.abs(group.y() - correctY) < PIECE_SIZE / 4) {
          group.position({ x: correctX, y: correctY });
          group.moveToBottom();
          layer.draw();
          const sound = document.getElementById('correctSound');
          sound.play().catch(error => console.error('Error al reproducir el sonido:', error));
          createHeartExplosion(correctX + PIECE_SIZE / 2, correctY + PIECE_SIZE / 2);
          checkPuzzleCompletion();
        }
      });

      return group;
    }

    function generatePuzzlePiecePath(row, col) {
      const s = PIECE_SIZE;
      const r = tabRadius;
      const w = tabWidth;
      const d = tabDepth;
      const p = tabPosition;

      const top = row === 0 ? 0 : connectors.top[row][col];
      const bottom = row === GRID_SIZE - 1 ? 0 : -connectors.top[row + 1][col];
      const left = col === 0 ? 0 : connectors.left[row][col];
      const right = col === GRID_SIZE - 1 ? 0 : -connectors.left[row][col + 1];

      let path = `M 0 0 `;

      path += `L ${p - w/2} 0 `;
      if (top !== 0) {
        path += `a ${w/2} ${d} 0 0 ${top > 0 ? 1 : 0} ${w} 0 `;
      }
      path += `L ${s} 0 `;

      path += `L ${s} ${p - w/2} `;
      if (right !== 0) {
        path += `a ${d} ${w/2} 0 0 ${right > 0 ? 1 : 0} 0 ${w} `;
      }
      path += `L ${s} ${s} `;

      path += `L ${p + w/2} ${s} `;
      if (bottom !== 0) {
        path += `a ${w/2} ${d} 0 0 ${bottom > 0 ? 1 : 0} -${w} 0 `;
      }
      path += `L 0 ${s} `;

      path += `L 0 ${p + w/2} `;
      if (left !== 0) {
        path += `a ${d} ${w/2} 0 0 ${left > 0 ? 1 : 0} 0 -${w} `;
      }
      path += `Z`;

      return path;
    }

    function shufflePieces(boardSize) {
      const margin = 10;
      const stageWidth = stage.width();
      const stageHeight = stage.height();
      pieces.forEach(p => {
        let x, y;
        if (window.innerWidth > 640) {
          // Desktop: prefer right side
          let pieceStartX = boardSize + margin;
          let pieceEndX = stageWidth - PIECE_SIZE - margin;
          if (pieceEndX < pieceStartX) {
            pieceStartX = margin;
            pieceEndX = stageWidth - PIECE_SIZE - margin;
          }
          const areaX = pieceEndX - pieceStartX;
          x = pieceStartX + Math.random() * areaX;

          let pieceStartY = margin;
          let pieceEndY = stageHeight - PIECE_SIZE - margin;
          const areaY = pieceEndY - pieceStartY;
          y = pieceStartY + Math.random() * areaY;
        } else {
          // Mobile: prefer below
          let pieceStartY = boardSize + margin;
          let pieceEndY = stageHeight - PIECE_SIZE - margin;
          if (pieceEndY < pieceStartY) {
            pieceStartY = margin;
            pieceEndY = stageHeight - PIECE_SIZE - margin;
          }
          const areaY = pieceEndY - pieceStartY;
          y = pieceStartY + Math.random() * areaY;

          let pieceStartX = margin;
          let pieceEndX = stageWidth - PIECE_SIZE - margin;
          const areaX = pieceEndX - pieceStartX;
          x = pieceStartX + Math.random() * areaX;
        }
        p.position({ x, y });
      });
      layer.draw();
    }

    function checkPuzzleCompletion() {
      if (pieces.every(p =>
        Math.abs(p.x() - p.attrs.correctX) < 1 &&
        Math.abs(p.y() - p.attrs.correctY) < 1)) {
        setTimeout(() => {
          document.getElementById('completionModal').style.display = 'flex';
        }, 500);
      }
    }

    function createHeartExplosion(x, y) {
      const heartCount = 12;
      const heartSize = PIECE_SIZE * 0.25;

      const heartPath = `M 0 ${heartSize * 0.2}
                   C -${heartSize * 0.65} -${heartSize * 0.35}, -${heartSize * 0.95}, ${heartSize * 0.15}, -${heartSize * 0.95}, ${heartSize * 0.55}
                   C -${heartSize * 0.95}, ${heartSize * 0.95}, -${heartSize * 0.35}, ${heartSize * 1.25}, 0, ${heartSize * 1.25}
                   C ${heartSize * 0.35}, ${heartSize * 1.25}, ${heartSize * 0.95}, ${heartSize * 0.95}, ${heartSize * 0.95}, ${heartSize * 0.55}
                   C ${heartSize * 0.95}, ${heartSize * 0.15}, ${heartSize * 0.65}, -${heartSize * 0.35}, 0, ${heartSize * 0.2} Z`;

      for (let i = 0; i < heartCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 60 + Math.random() * 120;
        const heart = new Konva.Path({
          x: x,
          y: y,
          data: heartPath,
          fill: '#db2777',
          scale: { x: 0.4, y: 0.4 },
          opacity: 2,
          rotation: Math.random() * 360
        });

        layer.add(heart);

        const anim = new Konva.Tween({
          node: heart,
          duration: 1.2,
          x: x + Math.cos(angle) * speed,
          y: y + Math.sin(angle) * speed,
          scaleX: 1.1,
          scaleY: 1.1,
          opacity: 0,
          rotation: heart.rotation() + 360,
          easing: Konva.Easings.EaseOut,
          onFinish: () => {
            heart.destroy();
            layer.draw();
          }
        });

        anim.play();
      }

      layer.draw();
    }
        const playPauseButton = document.getElementById('playPauseButton');
const backgroundMusic = document.getElementById('backgroundMusic');
let isPaused = true; // Start in paused state

playPauseButton.addEventListener('click', () => {
  isPaused = !isPaused;
  if (isPaused) {
    backgroundMusic.pause();
    playPauseButton.textContent = '▶';
  } else {
    backgroundMusic.play().catch(error => console.error('Error al reproducir la música:', error));
    playPauseButton.textContent = '⏸';
  }
});

// Ensure music is paused initially
backgroundMusic.pause();
 
    // Lógica para cerrar el modal
    const closeButton = document.getElementById('closeCompletionModal');
    closeButton.addEventListener('click', () => {
        document.getElementById('completionModal').style.display = 'none';
    });

    // Aplicar parámetros JSON personalizados
    if (jsonParams) {
      // Título de página
      if (jsonParams.page_title) document.title = String(jsonParams.page_title);

      // Título principal
      if (jsonParams.main_title) {
        const h1 = document.getElementById('mainTitle');
        if (h1) h1.textContent = String(jsonParams.main_title);
      }

      // Imagen del puzzle y preview
      if (jsonParams.puzzle_image) {
        imageObj.src = String(jsonParams.puzzle_image);
        const previewImg = document.getElementById('previewImage');
        if (previewImg) previewImg.src = String(jsonParams.puzzle_image);
      }

      // Textos del modal de completado
      if (jsonParams.completion_title) {
        const title = document.getElementById('completionTitle');
        if (title) title.textContent = String(jsonParams.completion_title);
      }
      if (jsonParams.completion_button) {
        const btn = document.getElementById('closeCompletionModal');
        if (btn) btn.textContent = String(jsonParams.completion_button);
      }

      // Música de fondo
      if (jsonParams.music_file) {
        const audio = document.getElementById('backgroundMusic');
        const source = audio.querySelector('source');
        if (source) {
          source.src = String(jsonParams.music_file);
          audio.load();
        }
      }
    }
  </script>
</body>
</html>


