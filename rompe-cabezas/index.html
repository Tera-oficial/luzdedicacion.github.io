<!doctype html>
<!-- Variable: page_title | text | Valor por defecto: Rompecabezas del Amor -->
<!-- Variable: main_title | text | Valor por defecto: Rompecabezas del Amor -->
<!-- Variable: puzzle_image | url | Valor por defecto: https://cdn.pensador.com/es/imagenes/sin-ti-mi-vida-tendri-a-menos-luz-te-amo-mi-amor.jpg -->
<!-- Variable: grid_size | text | Valor por defecto: 2 -->
<!-- Variable: completion_title | text | Valor por defecto: Este es el texto del final cuando termina el puzzle -->
<!-- Variable: completion_message | text | Valor por defecto: Â¡Lo lograste! Gracias por armar nuestro rompecabezas del amor. Te amo infinitamente. ðŸ’• -->
<!-- Variable: completion_button | text | Valor por defecto: Cerrar -->
<!-- Variable: music_file | url | Valor por defecto: Chino&Nacho - NiÃ±a Bonita.mp3 -->
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Rompecabezas del Amor</title>
  <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: linear-gradient(to bottom, #ffecf0, #fff0f5); overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; }
    h1 { color: #db2777; text-shadow: 0 2px 10px rgba(219,39,119,0.4); }
    .button-container button {
      background: linear-gradient(135deg, #ec4899, #f472b6);
      color: white;
      padding: 12px 28px;
      border-radius: 999px;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(236,72,153,0.4);
      transition: all 0.3s ease;
    }
    .button-container button:hover { transform: translateY(-3px); box-shadow: 0 10px 25px rgba(236,72,153,0.6); }
    #previewModal, #completionModal {
      position: fixed; inset: 0; background: rgba(0,0,0,0.7);
      display: none; align-items: center; justify-content: center; z-index: 9999;
    }
    #previewImage {
      max-width: 90vw; max-height: 80vh; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
    #completionModal div {
      background: white; padding: 2.5rem; border-radius: 20px; text-align: center;
      max-width: 90%; box-shadow: 0 10px 40px rgba(236,72,153,0.5);
    }
  </style>
</head>
<body class="flex flex-col items-center justify-start min-h-screen p-2 bg-gradient-to-b from-pink-50 to-pink-100">

  <canvas id="backgroundCanvas" class="fixed inset-0 z-0"></canvas>

  <h1 class="font-extrabold text-3xl sm:text-5xl md:text-6xl text-center text-pink-600 mt-4 mb-6 z-10" id="mainTitle">
    Rompecabezas del Amor
  </h1>

  <div id="container" class="mb-6 z-10 shadow-2xl rounded-xl overflow-hidden"></div>

  <div class="button-container flex flex-row justify-center items-center gap-4 sm:gap-6 w-full max-w-lg z-10">
    <button id="previewButton">Ver Imagen</button>
    <button id="playPauseButton">â–¶</button>
    <button id="resetButton">Reiniciar</button>
  </div>

  <audio id="backgroundMusic" src="Chino&Nacho - NiÃ±a Bonita.mp3" preload="auto" loop></audio>

  <!-- Modal de previsualizaciÃ³n -->
  <div id="previewModal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 hidden">
    <div class="relative max-w-4xl w-full p-4">
      <img id="previewImage" src="https://cdn.pensador.com/es/imagenes/sin-ti-mi-vida-tendri-a-menos-luz-te-amo-mi-amor.jpg" alt="Puzzle Preview" class="max-w-full max-h-[80vh] rounded-xl shadow-2xl">
      <button id="closeModal" class="absolute top-4 right-4 bg-white text-pink-600 px-4 py-2 rounded-full font-bold shadow-lg hover:bg-pink-100 transition">Cerrar</button>
    </div>
  </div>

  <!-- Modal de completado -->
  <div id="completionModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
    <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-lg w-full">
      <h2 class="text-3xl font-bold text-pink-600 mb-6" id="completionTitle">Este es el texto del final cuando termina el puzzle</h2>
      <p class="text-lg text-gray-700 mb-8" id="completionMessage">
        Â¡Lo lograste! Gracias por armar nuestro rompecabezas del amor.<br>
        Te amo infinitamente. ðŸ’•
      </p>
      <button id="closeCompletionModal" class="bg-pink-500 text-white px-8 py-3 rounded-full font-bold shadow-lg hover:bg-pink-600 transition">Cerrar</button>
    </div>
  </div>

  <script>
    // Fondo animado romÃ¡ntico (corazones y brillos)
    const canvas = document.getElementById('backgroundCanvas');
    const ctx = canvas.getContext('2d');
    let particles = [];

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initParticles();
    }

    function initParticles() {
      particles = [];
      const particleCount = Math.floor(window.innerWidth * window.innerHeight / 10000);
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 20 + 10,
          speedX: (Math.random() - 0.5) * 0.5,
          speedY: (Math.random() - 0.5) * 0.5,
          opacity: Math.random() * 0.5 + 0.3,
          type: Math.random() < 0.7 ? 'heart' : 'sparkle',
          rotation: Math.random() * 360,
          rotationSpeed: (Math.random() - 0.5) * 2
        });
      }
    }

    function drawHeart(x, y, size, rotation) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate((rotation * Math.PI) / 180);
      ctx.beginPath();
      ctx.moveTo(0, size * 0.3);
      ctx.bezierCurveTo(-size * 0.5, -size * 0.5, -size, -size * 0.2, -size, size * 0.3);
      ctx.bezierCurveTo(-size, size * 0.8, 0, size * 1.2, 0, size * 1.2);
      ctx.bezierCurveTo(0, size * 1.2, size, size * 0.8, size, size * 0.3);
      ctx.bezierCurveTo(size, -size * 0.2, size * 0.5, -size * 0.5, 0, size * 0.3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawSparkle(x, y, size) {
      ctx.beginPath();
      ctx.moveTo(x, y - size);
      ctx.lineTo(x, y + size);
      ctx.moveTo(x - size, y);
      ctx.lineTo(x + size, y);
      ctx.moveTo(x - size * 0.7, y - size * 0.7);
      ctx.lineTo(x + size * 0.7, y + size * 0.7);
      ctx.moveTo(x - size * 0.7, y + size * 0.7);
      ctx.lineTo(x + size * 0.7, y - size * 0.7);
      ctx.stroke();
    }

    function drawParticles() {
      ctx.fillStyle = 'rgba(251, 207, 232, 0.2)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      particles.forEach(p => {
        ctx.globalAlpha = p.opacity;
        if (p.type === 'heart') {
          ctx.fillStyle = `rgba(219, 39, 119, ${p.opacity})`;
          drawHeart(p.x, p.y, p.size / 2, p.rotation);
        } else {
          ctx.strokeStyle = `rgba(255, 255, 255, ${p.opacity})`;
          ctx.lineWidth = 2;
          drawSparkle(p.x, p.y, p.size / 2);
        }
        p.x += p.speedX;
        p.y += p.speedY;
        p.rotation += p.rotationSpeed;
        p.opacity = Math.max(0.3, p.opacity + (Math.random() - 0.5) * 0.02);
        if (p.x < 0 || p.x > canvas.width) p.speedX = -p.speedX;
        if (p.y < 0 || p.y > canvas.height) p.speedY = -p.speedY;
      });
      ctx.globalAlpha = 1;
    }

    function animateParticles() {
      drawParticles();
      requestAnimationFrame(animateParticles);
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    animateParticles();

    // === ROMPECABEZAS ===
    let GRID_SIZE = 2; // â† Valor por defecto, se puede sobrescribir con ?json={"grid_size": "4"}
    let PIECE_SIZE = 100;
    let stage, layer, slotLayer, pieces = [], imageObj = null;
    const connectors = { top: [], left: [] };
    let tabRadius, tabWidth, tabDepth, tabPosition;

    function calculateDimensions() {
      const availableWidth = window.innerWidth - 40;
      let ps = Math.floor(Math.min(availableWidth, 600) / GRID_SIZE);
      let boardSize = ps * GRID_SIZE;
      let extraWidth = 0;
      let extraHeight = 0;
      if (window.innerWidth > 640) {
        extraWidth = 400;
        extraHeight = 0;
      } else {
        extraWidth = 0;
        extraHeight = Math.max(250, ps * 2);
      }
      let totalWidth = boardSize + extraWidth;
      let totalHeight = boardSize + extraHeight;
      const maxTotalWidth = Math.min(availableWidth, 900);
      if (totalWidth > maxTotalWidth) {
        extraWidth = maxTotalWidth - boardSize;
        totalWidth = maxTotalWidth;
      }
      const maxTotalHeight = window.innerHeight - 140;
      if (totalHeight > maxTotalHeight) {
        extraHeight = maxTotalHeight - boardSize;
        totalHeight = maxTotalHeight;
      }
      return { ps, boardSize, extraWidth, extraHeight, totalWidth, totalHeight };
    }

    function initStage(boardSize, extraWidth, extraHeight) {
      stage = new Konva.Stage({
        container: 'container',
        width: boardSize + extraWidth,
        height: boardSize + extraHeight
      });
      slotLayer = new Konva.Layer();
      layer = new Konva.Layer();
      stage.add(slotLayer);
      stage.add(layer);
      const container = document.getElementById('container');
      container.style.width = `${boardSize + extraWidth}px`;
      container.style.height = `${boardSize + extraHeight}px`;
    }

    imageObj = new Image();
    imageObj.crossOrigin = "anonymous";
    imageObj.src = 'https://cdn.pensador.com/es/imagenes/sin-ti-mi-vida-tendri-a-menos-luz-te-amo-mi-amor.jpg';

    imageObj.onload = () => {
      const dims = calculateDimensions();
      PIECE_SIZE = dims.ps;
      tabRadius = PIECE_SIZE * 0.35;
      tabWidth = PIECE_SIZE * 0.4;
      tabDepth = PIECE_SIZE * 0.21;
      tabPosition = PIECE_SIZE * 0.5;
      initStage(dims.boardSize, dims.extraWidth, dims.extraHeight);
      createPuzzle();
    };

    document.getElementById('resetButton').addEventListener('click', () => {
      if (imageObj) {
        const dims = calculateDimensions();
        PIECE_SIZE = dims.ps;
        tabRadius = PIECE_SIZE * 0.35;
        tabWidth = PIECE_SIZE * 0.4;
        tabDepth = PIECE_SIZE * 0.21;
        tabPosition = PIECE_SIZE * 0.5;
        initStage(dims.boardSize, dims.extraWidth, dims.extraHeight);
        createPuzzle();
      }
    });

    document.getElementById('previewButton').addEventListener('click', () => {
      document.getElementById('previewModal').style.display = 'flex';
    });

    document.getElementById('closeModal').addEventListener('click', () => {
      document.getElementById('previewModal').style.display = 'none';
    });

    document.getElementById('closeCompletionModal').addEventListener('click', () => {
      document.getElementById('completionModal').style.display = 'none';
    });

    window.addEventListener('resize', () => {
      if (imageObj) {
        const dims = calculateDimensions();
        PIECE_SIZE = dims.ps;
        tabRadius = PIECE_SIZE * 0.35;
        tabWidth = PIECE_SIZE * 0.4;
        tabDepth = PIECE_SIZE * 0.21;
        tabPosition = PIECE_SIZE * 0.5;
        initStage(dims.boardSize, dims.extraWidth, dims.extraHeight);
        createPuzzle();
        resizeCanvas();
      }
    });

    function createPuzzle() {
      pieces = [];
      layer.removeChildren();
      slotLayer.removeChildren();
      connectors.top = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
      connectors.left = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          if (row > 0) {
            connectors.top[row][col] = -connectors.top[row - 1][col];
          } else {
            connectors.top[row][col] = Math.random() > 0.5 ? 1 : -1;
          }
          if (col > 0) {
            connectors.left[row][col] = -connectors.left[row][col - 1];
          } else {
            connectors.left[row][col] = Math.random() > 0.5 ? 1 : -1;
          }
        }
      }
      const boardSize = PIECE_SIZE * GRID_SIZE;
      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          const slot = new Konva.Path({
            x: col * PIECE_SIZE,
            y: row * PIECE_SIZE,
            data: generatePuzzlePiecePath(row, col),
            stroke: '#f9a8d4',
            strokeWidth: 1,
            dash: [4, 4]
          });
          slotLayer.add(slot);
          const piece = createPuzzlePiece(row, col);
          pieces.push(piece);
          layer.add(piece);
        }
      }
      slotLayer.draw();
      shufflePieces(boardSize);
      layer.draw();
    }

    function createPuzzlePiece(row, col) {
      const group = new Konva.Group({
        x: 0, y: 0,
        draggable: true,
        correctX: col * PIECE_SIZE,
        correctY: row * PIECE_SIZE,
        row, col,
        dragBoundFunc: function(pos) {
          const containerEl = stage.container();
          const maxX = containerEl.offsetWidth - PIECE_SIZE;
          const maxY = containerEl.offsetHeight - PIECE_SIZE;
          return {
            x: Math.max(0, Math.min(pos.x, maxX)),
            y: Math.max(0, Math.min(pos.y, maxY))
          };
        }
      });
      const fullSize = PIECE_SIZE * GRID_SIZE;
      const scaleX = imageObj.width / fullSize;
      const scaleY = imageObj.height / fullSize;
      const shape = new Konva.Path({
        x: 0, y: 0,
        data: generatePuzzlePiecePath(row, col),
        fillPatternImage: imageObj,
        fillPatternOffset: {
          x: col * PIECE_SIZE * scaleX,
          y: row * PIECE_SIZE * scaleY
        },
        fillPatternScale: {
          x: 1 / scaleX,
          y: 1 / scaleY
        },
        stroke: '#db2777',
        strokeWidth: 1
      });
      group.add(shape);
      group.on('dragstart touchstart', () => {
        group.moveToTop();
        layer.draw();
      });
      group.on('dragend touchend', () => {
        const { correctX, correctY } = group.attrs;
        if (Math.abs(group.x() - correctX) < PIECE_SIZE / 4 &&
            Math.abs(group.y() - correctY) < PIECE_SIZE / 4) {
          group.position({ x: correctX, y: correctY });
          group.moveToBottom();
          layer.draw();
          const sound = document.getElementById('correctSound');
          sound.currentTime = 0;
          sound.play().catch(() => {});
          createHeartExplosion(correctX + PIECE_SIZE / 2, correctY + PIECE_SIZE / 2);
          checkPuzzleCompletion();
        }
      });
      return group;
    }

    function generatePuzzlePiecePath(row, col) {
      const s = PIECE_SIZE;
      const r = tabRadius;
      const w = tabWidth;
      const d = tabDepth;
      const p = tabPosition;
      const top = row === 0 ? 0 : connectors.top[row][col];
      const bottom = row === GRID_SIZE - 1 ? 0 : -connectors.top[row + 1][col];
      const left = col === 0 ? 0 : connectors.left[row][col];
      const right = col === GRID_SIZE - 1 ? 0 : -connectors.left[row][col + 1];
      let path = `M 0 0 `;
      path += `L ${p - w/2} 0 `;
      if (top !== 0) {
        path += `a ${w/2} ${d} 0 0 ${top > 0 ? 1 : 0} ${w} 0 `;
      }
      path += `L ${s} 0 `;
      path += `L ${s} ${p - w/2} `;
      if (right !== 0) {
        path += `a ${d} ${w/2} 0 0 ${right > 0 ? 1 : 0} 0 ${w} `;
      }
      path += `L ${s} ${s} `;
      path += `L ${p + w/2} ${s} `;
      if (bottom !== 0) {
        path += `a ${w/2} ${d} 0 0 ${bottom > 0 ? 1 : 0} -${w} 0 `;
      }
      path += `L 0 ${s} `;
      path += `L 0 ${p + w/2} `;
      if (left !== 0) {
        path += `a ${d} ${w/2} 0 0 ${left > 0 ? 1 : 0} 0 -${w} `;
      }
      path += `Z`;
      return path;
    }

    function shufflePieces(boardSize) {
      const margin = 10;
      const stageWidth = stage.width();
      const stageHeight = stage.height();
      pieces.forEach(p => {
        let x, y;
        if (window.innerWidth > 640) {
          let pieceStartX = boardSize + margin;
          let pieceEndX = stageWidth - PIECE_SIZE - margin;
          if (pieceEndX < pieceStartX) {
            pieceStartX = margin;
            pieceEndX = stageWidth - PIECE_SIZE - margin;
          }
          const areaX = pieceEndX - pieceStartX;
          x = pieceStartX + Math.random() * areaX;
          let pieceStartY = margin;
          let pieceEndY = stageHeight - PIECE_SIZE - margin;
          const areaY = pieceEndY - pieceStartY;
          y = pieceStartY + Math.random() * areaY;
        } else {
          let pieceStartY = boardSize + margin;
          let pieceEndY = stageHeight - PIECE_SIZE - margin;
          if (pieceEndY < pieceStartY) {
            pieceStartY = margin;
            pieceEndY = stageHeight - PIECE_SIZE - margin;
          }
          const areaY = pieceEndY - pieceStartY;
          y = pieceStartY + Math.random() * areaY;
          let pieceStartX = margin;
          let pieceEndX = stageWidth - PIECE_SIZE - margin;
          const areaX = pieceEndX - pieceStartX;
          x = pieceStartX + Math.random() * areaX;
        }
        p.position({ x, y });
      });
      layer.draw();
    }

    function checkPuzzleCompletion() {
      if (pieces.every(p =>
        Math.abs(p.x() - p.attrs.correctX) < 1 &&
        Math.abs(p.y() - p.attrs.correctY) < 1)) {
        setTimeout(() => {
          document.getElementById('completionModal').style.display = 'flex';
        }, 500);
      }
    }

    function createHeartExplosion(x, y) {
      const heartCount = 12;
      const heartSize = PIECE_SIZE * 0.25;
      const heartPath = `M 0 ${heartSize * 0.2}
                   C -${heartSize * 0.65} -${heartSize * 0.35}, -${heartSize * 0.95}, ${heartSize * 0.15}, -${heartSize * 0.95}, ${heartSize * 0.55}
                   C -${heartSize * 0.95}, ${heartSize * 0.95}, -${heartSize * 0.35}, ${heartSize * 1.25}, 0, ${heartSize * 1.25}
                   C ${heartSize * 0.35}, ${heartSize * 1.25}, ${heartSize * 0.95}, ${heartSize * 0.95}, ${heartSize * 0.95}, ${heartSize * 0.55}
                   C ${heartSize * 0.95}, ${heartSize * 0.15}, ${heartSize * 0.65}, -${heartSize * 0.35}, 0, ${heartSize * 0.2} Z`;
      for (let i = 0; i < heartCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 60 + Math.random() * 120;
        const heart = new Konva.Path({
          x: x,
          y: y,
          data: heartPath,
          fill: '#db2777',
          scale: { x: 0.4, y: 0.4 },
          opacity: 2,
          rotation: Math.random() * 360
        });
        layer.add(heart);
        const anim = new Konva.Tween({
          node: heart,
          duration: 1.2,
          x: x + Math.cos(angle) * speed,
          y: y + Math.sin(angle) * speed,
          scaleX: 1.1,
          scaleY: 1.1,
          opacity: 0,
          rotation: heart.rotation() + 360,
          easing: Konva.Easings.EaseOut,
          onFinish: () => {
            heart.destroy();
            layer.draw();
          }
        });
        anim.play();
      }
      layer.draw();
    }

    // Control de mÃºsica
    const playPauseButton = document.getElementById('playPauseButton');
    const backgroundMusic = document.getElementById('backgroundMusic');
    let isPaused = true;
    playPauseButton.addEventListener('click', () => {
      isPaused = !isPaused;
      if (isPaused) {
        backgroundMusic.pause();
        playPauseButton.textContent = 'â–¶';
      } else {
        backgroundMusic.play().catch(() => {});
        playPauseButton.textContent = 'â¸';
      }
    });
    backgroundMusic.pause();

    // PersonalizaciÃ³n con ?json= (parche completo y funcional)
    function getJsonParam() {
      try {
        const url = new URL(window.location.href);
        const raw = url.searchParams.get('json');
        if (!raw) return null;
        const decoded = decodeURIComponent(raw);
        return JSON.parse(decoded);
      } catch (e) {
        return null;
      }
    }

    const json = getJsonParam();
    if (json) {
      // TÃ­tulo de la pÃ¡gina
      if (json.page_title) document.title = String(json.page_title);

      // TÃ­tulo principal
      if (json.main_title) {
        const h1 = document.querySelector('h1');
        if (h1) h1.textContent = String(json.main_title);
      }

      // Imagen del rompecabezas y previsualizaciÃ³n
      if (json.puzzle_image) {
        imageObj.src = String(json.puzzle_image);
        document.getElementById('previewImage').src = String(json.puzzle_image);
      }

      // TamaÃ±o del rompecabezas (grid)
      if (json.grid_size) {
        const newSize = parseInt(json.grid_size, 10);
        if (newSize >= 2 && newSize <= 8) {
          window.GRID_SIZE = newSize;
        }
      }

      // Textos del modal final
      if (json.completion_title) {
        const h2 = document.querySelector('#completionModal h2');
        if (h2) h2.textContent = String(json.completion_title);
      }
      if (json.completion_message) {
        const p = document.querySelector('#completionModal p');
        if (p) p.innerHTML = String(json.completion_message).replace(/\\n/g, '<br>');
      }
      if (json.completion_button) {
        const btn = document.getElementById('closeCompletionModal');
        if (btn) btn.textContent = String(json.completion_button);
      }

      // MÃºsica de fondo
      if (json.music_file) {
        const audio = document.getElementById('backgroundMusic');
        const source = audio.querySelector('source');
        if (source) {
          source.src = String(json.music_file);
          audio.load();
        }
      }
    }
  </script>
</body>
</html>
